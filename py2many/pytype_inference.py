import os
from pathlib import PosixPath
import hashlib

try:
    from pytype import analyze, errors, config, load_pytd
    from pytype.pytd import pytd_utils
    from pytype.tools.merge_pyi import merge_pyi

    log_errors = errors.ErrorLog()
except ModuleNotFoundError:
    import logging

    log_errors = logging.Logger("py2many")

    def pytype_annotate_and_merge(source, basedir, filename):
        return source


from py2many.helpers import parse_path


# Args class taken from pytd_utils
class Args:
    def __init__(self, as_comments=False):
        self.as_comments = as_comments

    @property
    def expected_ext(self):
        """Extension of expected filename."""
        exts = {
            0: "pep484",
            1: "comment",
        }
        return exts[int(self.as_comments)] + ".py"


def pytype_annotate_and_merge(src: str, basedir: PosixPath, filename: PosixPath):
    pre_parsed_base_dir = (
        f"{os.getcwd()}{os.sep}{basedir}"
        if os.path.isdir(f"{os.getcwd()}{os.sep}{basedir}")
        else f"{os.getcwd()}{os.sep}{basedir.parent}"
    )
    base_dir = parse_path(pre_parsed_base_dir.split(os.sep), os.sep)
    pyi_dir = f"{base_dir}_pyi"
    pyi_file = f"{pyi_dir}{os.sep}{filename.stem}.pyi"
    file_path = f"{base_dir}{os.sep}{filename}"
    pyi_log_file = f"{pyi_dir}{os.sep}.log"
    log_data: dict[str, str] = _read_log_file_contents(pyi_log_file)
    hash = _hashcontents(src)
    if file_path in log_data and hash == log_data[file_path]:
        # If a file already exists and is up-to-date,
        # use that instead of infering the types again
        print("Types already up-to-date")
        with open(pyi_file, "r") as f:
            pyi_src = f.read()
    else:
        # Otherwise, infer the types and create the .pyi file
        print("Infering Types")
        pyi_src = _infer_types(src)
        _write_to_pyi_file(pyi_dir, pyi_file, pyi_src)
        _append_to_log_file(pyi_log_file, (file_path, hash))
    # Create .gitignore to ignore .pyi data
    _create_gitignore(pyi_dir)
    # Set as_comments to 0
    args = Args(as_comments=0)
    annotated_src = merge_pyi.annotate_string(args, src, pyi_src)
    return annotated_src


def _infer_types(src):
    options = config.Options.create()
    # typed_ast is an instance of TypeDeclUnit
    typed_ast, _ = analyze.infer_types(
        src, log_errors, options, load_pytd.Loader(options)
    )
    return pytd_utils.Print(typed_ast)


def _write_to_pyi_file(pyi_dir: str, pyi_file: str, pyi_src: str):
    if not os.path.isdir(pyi_dir):
        os.mkdir(pyi_dir)
    with open(pyi_file, "w") as f:
        f.write(pyi_src)


def _hashcontents(contents: str):
    hash_object = hashlib.sha256(bytes(contents, "utf-8"))
    return hash_object.hexdigest()


def _read_log_file_contents(pyi_log_file):
    """Reads stored contents containing
    data about inferred python modules"""
    log_data = {}
    if os.path.isfile(pyi_log_file):
        with open(pyi_log_file, "r") as log:
            try:
                line = log.readline()
                while line:
                    mod_name, hash = line.split("-")
                    log_data[mod_name] = hash.strip()
                    line = log.readline()
            except:
                raise Exception("Wrong format for pytype log data")
    return log_data


def _append_to_log_file(pyi_log_file, data: tuple[str, str]):
    """Writes data of inferred python modules"""
    mod_name, hash = data
    with open(pyi_log_file, "a") as log:
        log.write(f"{mod_name}-{hash}\n")
        # log.writelines([f"{mod_name}-{hash}\n" for mod_name, hash in log_data.items()])


def _create_gitignore(pyi_dir):
    """Create a .gitignore similarly to how pytype does it"""
    pyi_gitignore = f"{pyi_dir}{os.sep}.gitignore"
    if not os.path.exists(pyi_gitignore):
        with open(pyi_gitignore, "w") as gitignore:
            gitignore.write("# Automatically generated by Py2Many\n")
            gitignore.write("*")
